---
---

# 00 - Rust

We will use the [Rust](https://www.rust-lang.org/) programming language for the labs.

## Resources
1. The Rust Programming Language, Chapters [1](https://doc.rust-lang.org/book/ch01-00-getting-started.html), [2](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html), [3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html), [4](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) and [5](https://doc.rust-lang.org/book/ch05-00-structs.html)
2. [Tour of Rust](https://tourofrust.com) step by step tutorial

## Basic programming language concepts for Rust

### Standard library

The standard library is divided into three levels:

| Level | Description | Needs |
|-------|:------------|:------|
| [`core`](https://doc.rust-lang.org/core/index.html) | Provides the required language elements that Rust needs for compiling, like the [`Display`](https://doc.rust-lang.org/core/fmt/trait.Display.html) and [`Debug`](https://doc.rust-lang.org/core/fmt/trait.Debug.html) traits. Data can only be global items (stored in *.data*) or on the *stack*. | Hardware |
| [`alloc`](https://doc.rust-lang.org/alloc/index.html) | Provides everything from the `core` level plus *heap* allocated data structures like, [`Box`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html) and [`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html). The developer has to provide a memory allocator, like [embedded_alloc](https://docs.rs/embedded-alloc/latest/embedded_alloc/). | Memory Allocator |
| [`std`](https://doc.rust-lang.org/std/index.html) | Provides everything from the `alloc` level plus a lot of features that depend on the platform, including threads and I/O. This is the default level for Windows, Linux, macOS and similar OSes applications. | Operating System |

:::note

This course will mostly use the `core` level of the standard library, as the software has to run on a [Raspberry Pi Pico](https://www.raspberrypi.com/products/raspberry-pi-pico/).

:::

By default, Rust has a set of elements defined in the standard library that are imported into the program of each application. This set is called the *prelude*, and you can look it up in the standard
library [documentation](https://doc.rust-lang.org/std/prelude/index.html).

If a type you want to use is not in the prelude, you must bring that type into scope explicitly with a `use`
statement. Using the `std::io` module gives you a number of useful features, including the ability to accept
user input.

```rust
use std::io; 
```

### The `main` function

The `main` function is the entry point of our program.

```rust
fn main() {
    println!("Hello, world!");
}
```

We use `println!` macro to print messages on the screen.

To insert a placeholder in the `println!` macro, use a *pair of braces* `{}` . We provide the variable name or
expression to replace the provided placeholder outside the string.

```rust
fn main() {

    let name = "Mary";
    let age = 26;

    println!("Hello, {}. You are {} years old", name, age);
    // if the replacements are only variable, one can use the inline version
    println!("Hello, {name}. You are {age} years old");
}
```

### Variables and mutability

We use the `let` keyword to create a variable.

```rust
    let a = 5;
```

By default, in Rust, variables are **immutable** , meaning once a value is tied to a name, you cannot
change that value.

Example:

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

In this case, we will get a compilation error because we are trying to modify the value of `x` from `5` to `6`, but
`x` is immutable, so we cannot make this modification.

Although variables are immutable by default, you can make them **mutable** by adding `mut` in front of the
variable name. Adding `mut` also conveys intent to future readers of the code by indicating that other parts
of the code will modify the value of this variable.

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

Now the value of `x` can become `6`.

### Constants

Like immutable variables, constants are values that are tied to a name and have a **value known at compile time**.

You are not allowed to use `mut` with constants. Constants are not only immutable by default,
they are always immutable. You declare constants using the `const` keyword instead of the `let` keyword. 
Constants's data type has to be specified at declaration.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

:::info 

For a better understanding, please read [chapter 3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html) of the documentation.

:::

### Data Types

#### Scalar types

A scalar type represents a single value. Rust has four main scalar types: integers, floating point numbers,
booleans, and characters.

**Integer** â†’ Each variant can be signed or unsigned and has an explicit size.
```rust
let x: i8 = -2;
let y: u16 = 25;
```

| Length              | Signed | Unsigned | Java Equivalent | C Equivalent[^c_equivalent] |
| :----------------: | :------: | :----: | :----: | :---: |
| 8-bit |   `i8`   | `u8` | `byte`/ `Byte`[^java_unsigned] | `char` / `unsigned char` |
| 16-bit |   `i16`   | `u16` | `short` / `Short`[^java_unsigned] | `short` / `unsigned short` |
| 32-bit |   `i32`   | `u32` | `int` / `Integer`[^java_unsigned] | `int` / `unsigned int` |
| 64-bit |   `i64`   | `u64` | `long` / `Long`[^java_unsigned] | `long long` / `unsigned long long` |
| 128-bit |   `i128`   | `u128` | N/A | N/A |
| arch |   `isize`   | `usize` | N/A | `int` / `unsigned int` |

**Floating Point** â†’ Rust's floating point types are `f32` and `f64`, which are 32-bit and 64-bit in size, respectively. The default type is `f64` because on modern CPUs it is about the same speed as `f32` but is capable of more precision. All floating point types are **signed**.

| Length              | Floating point | Java Equivalent| C Equivalent |
| :----------------: | :------: | :----: | :---: |
| 32-bit | `f32` | `float` | `float` |
| 64-bit | `f64` | `double` | `double` |
| 128-bit | `f128` | N/A | N/A |



```rust
fn main() {
    let x = 2.0; // f64
    let y1: f32 = 3.0; // f32
    let y2 = 3.0f32; // f32
}
```

**Boolean** â†’ Booleans are one byte in size. Boolean type in Rust is specified using bool.

```rust
let t = true;
let f: bool = false; // with explicit type annotation
```

**Character** â†’ The Rust char type is the most primitive alphabetic type in the language.

```rust
let c = 'z';
let z: char = 'â„¤'; // with explicit type annotation
let heart_eyed_cat = 'ðŸ˜»';
```

#### Compound types

**Tuple** â†’ A tuple is a structure used for grouping a number of values â€‹â€‹with a variety of types into a single compound type. Tuples have a **fixed** length  : once declared, their size cannot increase or decrease.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

**Array** â†’ Unlike a tuple, each element in an array must have the **same type**. Unlike arrays in some other languages, Rust arrays have a **fixed** length.

```rust
let a = [1, 2, 3, 4, 5];
```
:::info 

For a better understanding, please read [chapter 3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html) of the documentation.

:::

### Functions

We define a function in Rust by entering `fn` keyword followed by a function name and a set of parentheses. Curly braces tell the compiler where the function body begins and ends.

```rust
fn main() {
    println!("Hello, world!");
 
    another_function();
}
 
fn another_function() {
    println!("Another function.");
}
```
#### Parameters

We can define functions with parameters, which are special variables that are part of a function's signature. When a function has parameters, you can provide it with *concrete values* â€‹â€‹for those parameters, also called *arguments*.

```rust
fn main() {
    // the `another_function` function call has one single argument, the value 5.
    another_function(5);
}
 
// the `another_function`function has one single parameter `x` of type `i32`
fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
```

:::note 

In function signatures you must declare the type of each parameter!

:::

#### Declarations vs. expressions

Function bodies consist of a series of instructions optionally ending with an expression.

Declarations are **statements** that perform an action and do not return a value.

Expressions evaluate to a resulting value .

:::info 

For a better understanding, please read [chapter 3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html) of the documentation.

:::

#### Functions with return values

Functions can return values â€‹â€‹to the code that calls them. We don't name the return values, but we must declare their type after *an arrow* (`->`). In Rust, the function's return value is synonymous with the value of **the final expression** in a function's body block. You can return earlier from a function by using the `return` keyword and specifying a value, but most functions implicitly return the last expression.

```rust
fn five() -> i32 {
    5
}
 
fn main() {
    let x = five();
    println!("The value of x is: {x}");// "The value of x is: 5"
}
```

:::info 

For a better understanding, please read [chapter 3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html) of the documentation.

:::

### Control flow

#### if-else
All `if` expressions start with the `if` keyword , followed by a condition. Optionally, we can also include an `else` expression.

```rust
fn main() {
    let number = 3;
 
    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

You can use multiple conditions by combining `if` and `else` in an `else if` expression:

```rust
fn main() {
    let number = 6;
 
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

Because `if` is an expression, we can use it on **the right side** of a `let` statement to assign the result to a variable.

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };
 
    println!("The value of number is: {number}");//"The value of the number is 5"
}
```
#### loop

The `loop` keyword tells Rust to run a block of code over and over forever or until you **explicitly** tell it to stop.

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```
One use of a `loop` is to retry an operation that you know might fail, such as checking if a thread has finished its work. You may also need to pass the result of this operation out of the loop to the rest of your code. To do this, you can add the value you want to return after the `break` expression you use to stop the loop; this value will be returned out of the loop so you can use it:

```rust
fn main() {
    let mut counter = 0;
 
    let result = loop {
        counter += 1;
 
        if counter == 10 {
            break counter * 2;
        }
    };
 
    println!("The result is {result}");
}
```

#### while
```rust
fn main() {
    let mut number = 3;
 
    while number != 0 {
        println!("{number}!");
 
        number -= 1;
    }
 
    println!("LIFTOFF!!!");
}
```

#### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
 
    for element in a {
        println!("the value is: {element}");
    }
}
```

:::info 

For a better understanding, please read [chapter 3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html) of the documentation.

:::

### Complex Data Types

#### Structures

Structs are similar to tuples, in that they both contain multiple related values . Like tuples, pieces of a structure can be of different types. Unlike tuples, in a structure you **will name** each piece of data so that the meaning of the values â€‹â€‹is clear.

To define a structure, we enter the `struct` keyword and name the entire structure. The name of a structure should describe the meaning of the data elements grouped together. Then, within curly brackets, we define the names and types of the data, which we call **fields**.

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

To use a structure after having defined it, we create an **instance** of this structure by specifying concrete values â€‹â€‹for each of the fields. We create a **stack allocated** instance by specifying the structure name , then add curly braces containing `key:value` pairs , where the keys are the field names and the values â€‹â€‹are the data we want to store in those fields.

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```

To access a certain member of the structure we use this syntax:

```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
 
    user1.email = String::from("anotheremail@example.com")
}
```

:::warning 

Note that the entire instance must be **editable**  ; Rust **doesn't allow us** to mark only certain fields as mutable!

:::

As with any expression, we can construct a new instance of the structure as the last expression in the function body to implicitly return this new instance.

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

If we try to print an instance of `User` using the `println!` macro as we have seen early, it will not work.

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
 
    println!("User is: {}", user1);
}
```

We will get the following error message:
```
error[E0277]: `User` doesn't implement `std::fmt::Display`
```

In order to print a structure, we need to use `{:?}` instead of `{}`, and implement `Debug` trait for the structure with `#[derive(Debug)]`.

:::note

We use `Debug` trait to print structures, arrays, enums or any other type that doesn't implement `Display`.

:::


```rust
#[derive(Debug)]
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
 
    println!("User is: {:?}", user1);

    let x = [1, 2, 3];

    println!("Integer slice: {:?}", x);
}
```

Output:
```
User is: User { active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1 }
Integer slice: [1, 2, 3]
```

##### Tuple structs

Rust also supports structures that resemble tuples, called **tuple structs** . Tuple structures have the additional meaning provided by the structure name but do not have names associated with their fields; instead, they just have the field types. Tuple structures are useful when you want to name the entire tuple and make it a different type from other tuples, and when naming each field as in a regular structure would be wordy or redundant.

```rust
struct Color(i32, i32, i32);
struct Device(String, u8);
 
fn main() {
    let black = Color(0, 0, 0);
    let device = Device(String::from("Paspberry Pi Pico"), 2);
}
```


:::info 

For a better understanding, please read [chapter 5](https://doc.rust-lang.org/book/ch05-00-structs.html) of the documentation.

:::

#### Enums

Enumerations, also referred as `enums`, allow you to define a type by enumerating its possible variants.  
How to define an `enum`:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

### `Option` enum

`Option` is another `enum` defined by the standard library. The `Option` type encodes the very common scenario in which a value can be something or nothing.  

Rust **doesn't have the null** functionality that many other languages â€‹â€‹have. Null is a value that means there is no value here. In languages â€‹â€‹with null, variables can always be in one of two states: null or non-null.

As such, Rust does not have null values, but it does have an enumeration that can encode the concept of a value being present or absent. This enumeration is `Option<T>`, and it is defined by the standard library as follows:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

For now, all you need to know is that `<T>` means that the Some variant of the Option enumeration can contain data of **any type**.

```rust
fn integer_division (a:isize, b: isize) -> Option<isize> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}
```

When we have a `Some` value, we know that a value is present and that the value is contained in `Some`. When we have a `None` value, it kind of means the same thing as null: we don't have a valid value.

:::note

You must convert an `Option<T>` to a `T` before you can perform `T` operations with it.

:::

#### Match

Rust has an extremely powerful control flow construct called `match` that allows you to compare a value against a series of patterns and then run code based on which pattern matches. Patterns can consist of literal values, variable names, wildcards, and many other things.

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}
 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

When the match expression runs, it compares the resulting value to the model for each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If this pattern does not match the value, execution continues to the next arm.

The code associated with each arm is an **expression** , and the resulting value of the expression in the corresponding arm is the **returned value** for the entire matching expression.

In the previous section, we wanted to extract the internal `T` value of the Some case when using `Option<T>`; we can also handle `Option<T>` using match , like we did with the `Coin` enumeration! Instead of comparing parts, we will compare variants of `Option<T>`, but the way the `match` expression works remains the same.

```rust
fn main () {
    let x = 120;
    let y = 7;
    match integer_division (x, y) {
        Some(d) => println! ("{}:{} = {}", x, y, d),
        None => println! ("division by 0")
    };
}
```

:::info 

For a better understanding, please read [chapter 6](https://doc.rust-lang.org/book/ch06-00-enums.html) of the documentation.

:::


### String
Rust has only one type of string in the core language, which is the string slice `str` which is usually seen in its borrowed form `&str`.

The `String` type , which is provided by the Rust standard library rather than encoded in the main language, is a scalable, mutable, and owned UTF-8 encoded string type .

#### Creating a new String
```rust
    let mut s = String::new();
```
This line creates a new empty string called `s`, which we can then load data into.

We can use the `String::from` function or the `to_string` function to create a string from a string literal:
```rust
    let s = String::from("initial contents");
```
```rust
let data = "initial contents";
 
    let s = data.to_string();
 
    // the method also works on a literal directly:
    let s = "initial contents".to_string();
```

#### Adding to a string

We can expand a string using the `push_str` method to add a string slice.
```rust
let mut s = String::from("foo");
s.push_str("bar");
```
**The push** method takes **a single character** as a parameter and adds it to the string.

```rust
    let mut s = String::from("lo");
    s.push('l');
```
#### Iteration Methods on Strings

The best way to operate on pieces of strings is to be explicit about whether you want characters or bytes. For individual Unicode scalar values, use the `chars` method .
```rust
for c in "Ð—Ð´".chars() {
    println!("{}", c);
}
```

### Ownership
In Rust, there is a concept called data ownership. It states that any data should only have one owner, and when the owner goes out of scope the data is freed. Take this C code sequence:
```c
char* x = calloc(50,1);
strcat(x, "hello");
char* y = x;
strcat(y, " world!");
printf("%s\n", x); // Prints out "hello world!"
```
Since x and y are both addresses, and they point to the same location, once we modify the contents of y the modifications will also be seen in x. However, the equivalent rust code returns this error:

```rust
let mut s = "hello".to_string();
let mut y = s;
y.push_str(" world!");
println!("{s}"); // error[E0382]: borrow of moved value: `s`
```
In this case, if the println did not have any error it would have meant that at that point the string referenced by ```s``` would have had multiple owners. To prevent this from breaking the ownership rules, the compiler has **moved** the variable ```s``` into ```y```. This means that ```s``` is no longer usable and will get shallowly copied to the destination[^move_might_be_optimized]. 
This prevents the compiler from having to keep a reference count at runtime and avoids potential double free-ing when both ```s``` and ```y``` go out of scope.

:::tip

If you want the code to compile, you must explicitly call ```s.clone()```, which will make a new memory location with a deep copy.
Since the memory locations are different for ```y``` and ```s```, modifying ```y``` will not affect ```s```

:::

If you have a function, the caller will transfer ownership of the parameters to the function, and the return value of the function will have its ownership transfered to the caller:
```rust
fn pick(a:String, b:String) -> String {
    if !a.is_empty() {
        a
    } else {
        b
    }
}
let s1 = "hello".to_string(); // s1 valid
let s2 = "there".to_string(); // s1, s2 valid
let s3 = pick(s1, s2); // s3 valid, s1 and s2 moved
```

#### Owning and borrowing
If every action to data would require taking ownership of it, the code would get too complicated to write. This is why the compiler also allows you to borrow a reference to the data if in your use case you do not want to take ownership of it like this:
```rust
let s = "hello".to_string();
let x = &s; // immutable reference
if x.is_empty() {
    println!("No greeting...");
}
println!("{}", s); // s is still valid
```

You may have immutable references like this: ```&x``` or mutable references like this: ```&mut x``` (valid only if x is declared as mutable). There are a few rules that you must follow in order for the program to compile:

- You are not allowed to do a mutable and an immutable borrow to the same variable at the same time
```rust
let mut s = "Hello".to_string();
let ib = &s;
let mb = &mut s; // error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
println!("{ib}{mb}");
```
- You are only allowed 1 mutable borrow at a time
```rust
let mut s = "Hello".to_string();
let mb1 = &mut s;
let mb2 = &mut s; // error[E0499]: cannot borrow `s` as mutable more than once at a time
println!("{mb1}{mb2}");
```
- You can have as many immutable borrows at a time
```rust
let mut s = "Hello".to_string();
let ib1 = & s;
let ib2 = & s;
println!("{ib1}{ib2}"); // HelloHello
```
- You cannot move the owned value while something is borrowing it
```rust
let mut s = "Hello".to_string();
let ib1 = & s;
let s2 = s; // error[E0505]: cannot move out of `s` because it is borrowed
println!("{ib1}");
```
- A borrow becomes invalid if the owned value goes out of scope
```rust
let x = {
    let s = "Hello".to_string();
    &s // returns reference to dropped value => error
};
println("{x}");
```
- A borrow will be held for as long as it is used:
```rust
let mut s = "Hello".to_string();
let mb1 = &mut s;
let mb2 = &mut s; // Valid since mb1 is not used after this point
println!("{mb2}");
```
:::info

For a more thorough explanation of ownership and borrowing refer to [chapter 4](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) of the book.

:::

#### Copy trait
Let's take a similar code to the one presented before:
```rust
let mut x:i32 = 0;
let mut y = x;
y = 5;
println("{x}"); // Prints 0
```
This time, the compiler seems to not have moved the variable ```x``` into ```y```. Why? Because i32 implements [`Copy`](https://doc.rust-lang.org/core/marker/trait.Copy.html). This is a trait used for types that are inexpensive to duplicate bit by bit, and which also do not allow 2 mutable references to the same location in memory.

|Type|Implements Copy|
|---|---|
|i32|	Yes|
|f64|	Yes|
|bool|	Yes|
|String|	No|
|&str| Yes|
|&mut str| No|

You may implement the Copy trait to your structs and enums by using ```#[derive(Clone, Copy)]```

:::note

You **must** implement Clone in order to derive Copy. Also, all of the fields must have types that implement Copy.

:::

### Run the program
In order to run the program we may be anywhere in the crate's folder and execute the command:

```bash
cargo run
```

## Exercises

:::tip 

If you don't have Rust installed, you can use [Rust Playground](https://play.rust-lang.org/) to solve the topics.

:::

:::info

Before tackling the exercises, take a look and cover chapters [1](https://tourofrust.com/chapter_1_en.html), [2](https://tourofrust.com/chapter_2_en.html) and [3](https://tourofrust.com/chapter_3_en.html) of [Tour of Rust](https://tourofrust.com/) tutorials.

:::

1. Write a function that takes your name as a parameter and greets you to stdout. What type should the parameter have and why? (**1p**).
2. Write a function that takes an unsigned integer N as a parameter and prints out the first N prime numbers (**1p**).
3. Rewrite the first function, but this time implement it using the [Sieve of Erathostenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/) (**2p**).
4. Define a struct called MiniTuring, with a buffer of 256 booleans and a cursor. (**3p**)
  - Write an associated (static) function called new that creates an instance of the structure.
  - Write a method called display that prints the tape with 1's and 0's instead of trues and falses, without newlines or spaces in between
  - Read the keyboard until "h" is received. "l" will move the cursor to the left with wrap around, "r" will move the cursor to the right with wrap around, "1" will set the element at the cursor to true, "0" will set the element at the cursor to false, "p" prints the value at cursor, "h" displays the tape
5. Create a basic expression parser for integer numbers, which supports +,-,*,/. Assume unary - will not happen (no expressions like 5\*-3, -2+7) (**3p**).
  - Define an enum called Expression with the appropriate variants(hint: use [`Box`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html))
  - Create a function that returns an Expression based on a given string. Respect operator precedence rules
  - Creates a function that takes an Expression and evaluates it to an i32
  - Read an expression from stdin and print out the result


[^c_equivalent]: The data types used here are considered for a 32 bit system, for other architectures the equivalent data types might differ (`short` is at least 2 bytes long).
[^java_unsigned]: Starting with Java 8, the `Number` classes have some helper methods, like `compareUnsigned` and `toUnsigned...` that allow the usage and manipulation of unsigned numbers.
[^move_might_be_optimized]: The compiler might optimize out the shallow copy. https://users.rust-lang.org/t/how-move-works-in-rust/116776/19