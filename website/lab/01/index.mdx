---
description: Using debug tools to run embassy-rs firmware 
slug: /lab/01
---

# 01 - Debug

This lab will teach you how to debug and run programs written in Rust and [embassy](https://embassy.dev) on he Raspberry Pi Pico boards.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Concepts

- What is the microcontroller's *debugging interface*
- What is a debugger
- What is debugging software
- How to use *probe-rs* for RP2 processors
- How to use the Visual Studio Code probe-rs extension

## Resources

1. **Raspberry Pi Ltd**, *[RP2350 Datasheet](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf)*
- Chapter 4 - *Memory*
  - Section 4.1 - *ROM*
  - Section 4.2 - *SRAM*
  - Section 4.3 - *Boot RAM*
- Chapter 5 - *Bootrom*
2. [probe-rs's documentation](https://probe.rs/docs/overview/about-probe-rs/)
3. [rp235x-hal documentation](https://docs.rs/rp235x-hal/latest/rp235x_hal/index.html)
4. [Embassy documentation](https://embassy.dev/book/dev/runtime.html)

## Debugger

Developing software (*firmware*[^firmware]) on devices is a little different from standard computer applications. The main difference
is that the software is developed and compiled on the computer and then 
uploaded and run on a separate device.

Each development board defines its own way of uploading software to it. Some boards, like the Raspberry Pi Picos, provide a *simulated* USB drive
where users can copy a file, others, like the ESP32 boards, provide a WiFi Access Point and a web interface.

One way that all boards have in common is *debug interface*. Microcontrollers provide a special hardware interface
for debugging purposes. Using specialized hardware, developers can:
- stop the processor any time
- ask the processor to execute one instruction at a time
- read and write the processor's memory (RAM)
- read and write the processor's Flash (Storage)
- read the processor's registers
- access special debugging interfaces for sending log messages

These functions allow developers to upload programs and observe the program's behavior.

There are several debugging protocols available, the most common of then being JTAG and SWD. The RP2 processors use SWD.

:::warning
When placed in production, the **debug interface should be disabled**. users of the production device should 
never be able to access such an interface and tamper with the device's program.

Each micrcontroller offers a way in which de debug interface can be permanently disabled or restricted.
:::

The Raspberry Pi Pico can be debugged using one of the two pieces of hardware:
- The Raspberry Pi Debug Probe
- A secondary Raspberry Pi Pico

### Raspberry Pi Debug Probe

Professional debuggers, while offering a lot of features, are usually expensive. Raspberry Pi provides the [Debug Probe](https://www.raspberrypi.com/products/debug-probe/), an affordable debug device
that uses an RP2040 processor. It is similar to a Raspberry Pi Pico board, just that it has a smaller form factor and
provides debug cables. 

The firmware running on the debug device is open source and available on [github](https://github.com/raspberrypi/debugprobe). It is written in C and 
it uses [FreeRTOS](https://www.freertos.org). It is compatible with both versions of the RP2 processors, RP2040 and RP2350.

### Secondary Pico

As the debugger's firmware is open source, an additional Raspberry Pi Pico can be used as a debugger.

TODO connections

:::info
The lab board uses RP2040 processor soldered to the PCB as a debugger. It runs the [debugprobe](https://github.com/raspberrypi/debugprobe) firmware and has 
traces soldered to Raspberry Pi Pico's socket.
:::


## Debugger software

Hardware debuggers require specialized software on the host computer (the computer used for development) to 
communicate with and control the target device (the Raspberry Pi Pico 2 in this case). These software tools provide 
essential debugging capabilities, such as setting breakpoints, inspecting 
memory, and stepping through code execution. While most debugger vendors offer 
proprietary software tailored to their specific hardware, developers often seek 
more flexible or platform-independent solutions. Fortunately, there are several 
open-source alternatives that support a wide range of debugging probes and 
microcontrollers.

One widely used open-source tool is [OpenOCD](https://openocd.org), which 
provides a powerful and configurable interface for debugging and programming 
ARM and RISC-V devices, including the Raspberry Pi Pico 2. OpenOCD supports a 
variety of debug probes and allows integration with GDB for source-level 
debugging.

Another popular option is [PyOCD](https://pyocd.io), a Python-based tool 
designed primarily for ARM Cortex-M microcontrollers. It offers an easy-to-use 
command-line interface, built-in support for CMSIS-DAP debug probes, and 
seamless integration with debugging environments like GDB and Visual Studio 
Code.

For developers working in Rust or looking for an alternative that is optimized 
for modern workflows, [probe-rs](https://probe.rs) provides a Rust-based 
debugging and flashing tool that supports multiple probe types, including 
CMSIS-DAP and J-Link. It offers a simple API, making it a great choice for both 
manual debugging and automated workflows.

## Flashing firmware

To run firmware on the Raspberry Pi Pico 2, the 
compiled program must be transferred to the device's flash (non-volatile) memory. This 
process is called *flashing*, and it ensures that the firmware remains on the 
device even after a power reset. 

A flashing tool is software that communicates 
with the device through a debug probe or other interfaces, such as USB or 
UART, to write the firmware to the correct memory location. Many flashing tools 
also verify the uploaded firmware to ensure data integrity and provide 
additional features like chip erasing or memory protection configuration.

When developing Rust firmware for the Raspberry Pi Pico 2, `probe-rs` is the 
proffered flashing tool to upload and debug code. 

Using `cargo run`, developers can 
compile their project and flash the firmware onto the target device in a single 
command. This workflow simplifies development by eliminating the need for 
separate flashing tools. Under the hood, `cargo run` invokes `probe-rs` to 
detect the connected debug probe and automatically handle the flashing process. 

## Binary format

To be able ro properly run the code, the Raspberry Pi Pico (1 and 2) expects a certain binary format.
The compiler and the linker, both provided by Rust, have to make sure that the generated
binary code meets the requirements, otherwise the Raspberry Pi Pico will not start.

### Sections

The binary file is generated as a collection of sections. Each section has:
- size (in bytes)
- the address of the section in RAM when the firmware runs (`VMA`, *Virtual Memory Address*) 
- the address of the section when it is stored into flash (`LMA`, *Load Memory Address*)
- the type

#### Section types
| Type | Description |
|-|-|
| *TEXT* | Contains the binary code the the processor executes |
| *DATA* | Contains data used by the firmware, usually variables |
| *BSS* | Contains uninitialized or initialized with `0` data, usually uninitialized global variables and variables initialized to 0 |
| *DEBUG* | Contains debug information used by the debugger software. |

:::info
DEBUG type sections have no addresses (`0x00000000`), as it they are never loaded to the device. These sections
are used by the debugging software to display meaningful information to developers. Among the information
store here we can find:
- source code to binary code mappings
- variable name mappings
- function name mappings
:::

The binary file for the Raspberry Pi Pico 2 is organized to ensure proper 
execution and booting, with specific sections for the developer's code and 
variables. The first section that holds the developer’s code is the *`.text`* 
section. This section contains all the executable instructions that make up 
the application’s logic. It is located after the *`.start_block`* and 
*`.vector_table`* sections, and it is placed into flash memory, ready to 
be loaded and executed when the system starts. This is where the developer's 
main program logic resides.

Following the *`.text`* section, the *`.data`* section contains 
initialized global and static variables. These variables are stored in flash 
memory and are copied into RAM at startup. The developer’s predefined values 
for global variables are stored here, so they can be used during runtime. 
In contrast, the *`.bss`* section holds uninitialized variables. These 
variables are zeroed out during the boot process and are stored in RAM to 
ensure that the program can access them during execution.

The *`.rodata`* section follows, storing read-only data like string literals 
and constant values. These values are also stored in flash memory and are used 
throughout the application without modification. The *`.rodata`* section 
helps to conserve RAM by storing constant data in the flash memory instead.

Once the developer’s code and variables are in place, the firmware image ends 
with the *`.end_block`* section. This section marks the end of the firmware 
and ensures that no additional data is written past this point. It is important 
for memory management, preventing the accidental overwrite of critical memory 
regions during updates or execution.

### Inspect binaries

When working in Rust for the Raspberry Pi Pico 2, `rust-objdump` can be used to 
inspect the compiled binary and examine its memory layout. The output includes 
various sections that are crucial for embedded development.  

| Section         | Fixed Offset  | Description |
|----------------|--------------|-------------|
| *`.vector_table`* | `0x10000000` | Contains the initial stack pointer value and interrupt vector table. Essential for system startup and exception handling, allowing the processor to correctly respond to interrupts. |
| *`.start_block`* | `0x10000114` | Holds boot metadata, including information needed by the bootloader to validate and execute the firmware correctly. Ensures that the correct application runs after a reset. |
| *`.text`* | N/A | Stores executable code, typically placed in flash memory. Optimizing this section can reduce flash usage and improve execution efficiency. |
| *`.rodata`* | N/A | Contains read-only data, such as string literals and constants, stored in flash memory. Helps minimize RAM usage. |
| *`.data`* | N/A | Includes initialized variables that are stored in flash and copied to RAM during startup. Used for global and static variables requiring predefined values. |
| *`.bss`* | N/A | Represents uninitialized variables that are zeroed out in RAM before execution. Large `.bss` sections can impact RAM availability. |
| *`.bi_entries`* | N/A | Contains boot information entries used by the RP2350 ROM bootloader and firmware updater to manage and validate firmware images. |
| *`.end_block`* | N/A | Marks the end of the firmware image. This section helps bootloaders determine the total size of the firmware and ensures that no unexpected data is included beyond this point. It is used for integrity checks and defining boundaries for updates or memory protection. |


#### Pico 1 vs Pico 2
The primary difference between the Raspberry Pi Pico 1 and Pico 2 in terms of 
firmware layout is the presence of the *`.boot_loader`* section in the Pico 1, 
which is not present in the Pico 2. The *`.boot_loader`* section in the Pico 1 
is located at a fixed offset of `0x10000000` and contains the bootloader code 
along with necessary metadata for bootstrapping the device. 

The *`.vector_table`*  section in the Pico 1 is placed immediately 
after the *`.boot_loader`* section, 
unlike the Pico 2 where it is located at the beginning of the flash memory at 
`0x00000000`. 

The Pico 2 uses the *`.start_block`* and *`.end_block`* sections 
to handle boot metadata and firmware boundaries, while the Pico 1 relies on the 
bootloader for these tasks. Furthermore, the Pico 1 does not have a fixed 
*`.end_block`* section, which is used in the Pico 2 to mark the end of the 
firmware image. 

Despite these differences, both devices share a similar overall 
firmware structure, with the *`.text`*, *`.rodata`*, *`.data`*, and *`.bss`* 
sections serving similar purposes in both devices.


### Install cargo binutils
Before you can use `rust-objdump` with Rust projects, you'll need to install `cargo-binutils`.


```bash
cargo install cargo-binutils
rustup component add llvm-tools
```

### Check section headers

<Tabs>
  <TabItem value="rp2350" label="Raspberry Pi Pico 2" default>

```shell
rust-objdump --section-headers target/thumbv8m.main-none-eabihf/debug/<executable_name>
```

```shell
Sections:
Idx Name            Size     VMA      LMA      Type
  0                 00000000 00000000 00000000 
  1 .vector_table   00000114 10000000 10000000 DATA
  2 .start_block    00000028 10000114 10000114 DATA
  3 .text           0000b190 1000013c 1000013c TEXT
  4 .bi_entries     00000010 1000b2cc 1000b2cc DATA
  5 .rodata         000030e4 1000b2e0 1000b2e0 DATA
  6 .data           00000488 20000000 1000e3c4 TEXT
  7 .gnu.sgstubs    00000000 1000e860 1000e860 DATA
  8 .bss            000181bc 20000488 20000488 BSS
  9 .uninit         00000400 20018644 20018644 BSS
 10 .end_block      00000000 1000e860 1000e860 DATA
 11 .defmt          00000023 00000000 00000000 
 12 .debug_abbrev   0000b8bb 00000000 00000000 DEBUG
 13 .debug_info     000ea40f 00000000 00000000 DEBUG
 14 .debug_aranges  00009a70 00000000 00000000 DEBUG
 15 .debug_ranges   00032380 00000000 00000000 DEBUG
 16 .debug_str      000eff8d 00000000 00000000 DEBUG
 17 .comment        00000099 00000000 00000000 
 18 .ARM.attributes 0000003a 00000000 00000000 
 19 .debug_frame    0001b444 00000000 00000000 DEBUG
 20 .debug_line     0006ed68 00000000 00000000 DEBUG
 21 .debug_loc      00001e3a 00000000 00000000 DEBUG
 22 .symtab         00007530 00000000 00000000 
 23 .shstrtab       00000101 00000000 00000000 
 24 .strtab         0000f6ca 00000000 00000000 
```

  </TabItem>
  <TabItem value="rp2040" label="Raspberry Pi Pico">

```shell
rust-objdump --section-headers target/thumbv6m-none-eabi/debug/<executable_name>
```

```shell
Sections:
Idx Name            Size     VMA      Type
  0                 00000000 00000000 
  1 .vector_table   000000c0 10000100 DATA
  2 .boot_loader    00000100 10000000 DATA
  3 .text           00000b10 100001c0 TEXT
  4 .rodata         000001a4 10000cd0 DATA
  5 .data           00000000 20000000 DATA
  6 .gnu.sgstubs    00000000 10000e80 TEXT
  7 .bss            00000000 20000000 BSS
  8 .uninit         00000000 20000000 BSS
  9 .debug_abbrev   00001bce 00000000 DEBUG
 10 .debug_info     00025316 00000000 DEBUG
 11 .debug_aranges  000014b8 00000000 DEBUG
 12 .debug_str      0003c860 00000000 DEBUG
 13 .debug_pubnames 000175c6 00000000 DEBUG
 14 .debug_pubtypes 00000ee6 00000000 DEBUG
 15 .comment        00000073 00000000 
 16 .ARM.attributes 00000032 00000000 
 17 .debug_frame    00004444 00000000 DEBUG
 18 .debug_line     00023790 00000000 DEBUG
 19 .debug_ranges   00016df8 00000000 DEBUG
 20 .debug_loc      00000074 00000000 DEBUG
 21 .symtab         00000970 00000000 
 22 .shstrtab       00000103 00000000 
 23 .strtab         00000fe4 00000000 
```
  
  </TabItem>
</Tabs>





### Disassemble a specific section

```bash
rust-objdump --disassemble -j .section_name target/thumbv6m-none-eabi/debug/<executable_name>
```

:::info

`cargo objdumb` and `rust-objdump` tools use llvm's `objdump` tool.
Some terminals do not parse parameters proxied to `llvm-objdump` command.
If this happens please use `llvm-objdump` script directly like so

```shell
llvm-objdump <path_to_binary> --section.headers
```

:::

[^firmware]: Software that is running on microcontrollers is usually called *firmware*. The words is a combination of the words *firm* and *software* and means the software that the vendor firm of the device has uploaded.