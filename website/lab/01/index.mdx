---
description: Using debug tools to run embassy-rs firmware 
slug: /lab/01
---

# 01 - Debug

This lab will teach you how to debug and run programs written in Rust and [embassy](https://embassy.dev) on he Raspberry Pi Pico boards.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Concepts

- What is the microcontroller's *debugging interface*
- What is a debugger
- What is debugging software
- How to use *probe-rs* for RP2 processors
- How to use the Visual Studio Code probe-rs extension

## Resources

1. **Raspberry Pi Ltd**, *[RP2350 Datasheet](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf)*
- Chapter 4 - *Memory*
  - Section 4.1 - *ROM*
  - Section 4.2 - *SRAM*
  - Section 4.3 - *Boot RAM*
- Chapter 5 - *Bootrom*
2. [probe-rs's documentation](https://probe.rs/docs/overview/about-probe-rs/)
3. [rp235x-hal documentation](https://docs.rs/rp235x-hal/latest/rp235x_hal/index.html)
4. [Embassy documentation](https://embassy.dev/book/dev/runtime.html)

## Debugger

Developing software (*firmware*[^firmware]) on devices is a little different from standard computer applications. The main difference
is that the software is developed and compiled on the computer and then 
uploaded and run on a separate device.

Each development board defines its own way of uploading software to it. Some boards, like the Raspberry Pi Picos, provide a *simulated* USB drive
where users can copy a file, others, like the ESP32 boards, provide a WiFi Access Point and a web interface.

One way that all boards have in common is *debug interface*. Microcontrollers provide a special hardware interface
for debugging purposes. Using specialized hardware, developers can:
- stop the processor any time
- ask the processor to execute one instruction at a time
- read and write the processor's memory (RAM)
- read and write the processor's Flash (Storage)
- read the processor's registers
- access special debugging interfaces for sending log messages

These functions allow developers to upload programs and observe the program's behavior.

There are several debugging protocols available, the most common of then being JTAG and SWD. The RP2 processors use SWD.

:::warning
When placed in production, the **debug interface should be disabled**. users of the production device should 
never be able to access such an interface and tamper with the device's program.

Each micrcontroller offers a way in which de debug interface can be permanently disabled or restricted.
:::

The Raspberry Pi Pico can be debugged using one of the two pieces of hardware:
- The Raspberry Pi Debug Probe
- A secondary Raspberry Pi Pico

### Raspberry Pi Debug Probe

Professional debuggers, while offering a lot of features, are usually expensive. Raspberry Pi provides the [Debug Probe](https://www.raspberrypi.com/products/debug-probe/), an affordable debug device
that uses an RP2040 processor. It is similar to a Raspberry Pi Pico board, just that it has a smaller form factor and
provides debug cables. 

The firmware running on the debug device is open source and available on [github](https://github.com/raspberrypi/debugprobe). It is written in C and 
it uses [FreeRTOS](https://www.freertos.org). It is compatible with both versions of the RP2 processors, RP2040 and RP2350.

### Secondary Pico

As the debugger's firmware is open source, an additional Raspberry Pi Pico can be used as a debugger.

TODO connections

:::info
The lab board uses RP2040 processor soldered to the PCB as a debugger. It runs the [debugprobe](https://github.com/raspberrypi/debugprobe) firmware and has 
traces soldered to Raspberry Pi Pico's socket.
:::


## Debugger software

Hardware debuggers require specialized software on the host computer (the computer used for development) to 
communicate with and control the target device (the Raspberry Pi Pico 2 in this case). These software tools provide 
essential debugging capabilities, such as setting breakpoints, inspecting 
memory, and stepping through code execution. While most debugger vendors offer 
proprietary software tailored to their specific hardware, developers often seek 
more flexible or platform-independent solutions. Fortunately, there are several 
open-source alternatives that support a wide range of debugging probes and 
microcontrollers.

One widely used open-source tool is [OpenOCD](https://openocd.org), which 
provides a powerful and configurable interface for debugging and programming 
ARM and RISC-V devices, including the Raspberry Pi Pico 2. OpenOCD supports a 
variety of debug probes and allows integration with GDB for source-level 
debugging.

Another popular option is [PyOCD](https://pyocd.io), a Python-based tool 
designed primarily for ARM Cortex-M microcontrollers. It offers an easy-to-use 
command-line interface, built-in support for CMSIS-DAP debug probes, and 
seamless integration with debugging environments like GDB and Visual Studio 
Code.

For developers working in Rust or looking for an alternative that is optimized 
for modern workflows, [probe-rs](https://probe.rs) provides a Rust-based 
debugging and flashing tool that supports multiple probe types, including 
CMSIS-DAP and J-Link. It offers a simple API, making it a great choice for both 
manual debugging and automated workflows.

## Cross-compiling

Cross-compiling is the process of building software on one system (the host) 
that is intended to run on a different system (the target). This is necessary 
when developing for embedded systems like the Raspberry Pi Pico 2 because the 
target device has a different processor architecture than the development 
computer. Unlike normal compiling, where the compiled binary runs on the same 
system that builds it, cross-compiling generates machine code suitable for the 
target architecture. 

In Rust, this is handled by specifying a target triple. 
For example, when using `cargo build` for embedded development, Rust compiles 
the firmware for the microcontroller's architecture and flashes it to the 
device. 

For example, cross-compiling for the Raspberry Pi Pico 2 requires the
`thumbv8m.main-none-eabihf` triple. It tells the compiler to build code
for:
- the **ARMv8-M Mainline** (`thumbv8m.main`) architecture
- that runs bare meta, **without an operating system** available (`none`)
- and uses the **Embedded Application Binary Interface** (`eabi`) **with hardware floating point** support

```sh
cargo build --target thumbv8m.main-none-eabihf
```

### Using a configuration file

Instead of providing the target triple in the command line every time, `cargo` offers the 
possibility of writing it in a configuration file called `.cargo/cargo.toml`.
 
```toml
[build]
target = "thumbv8m.main-none-eabihf"
```

This sets the default compilation target to `thumbv8m.main-none-eabihf`,
ensuring that `cargo` always builds the project for an *ARMv8-M Mainline*
microcontroller with hardware floating-point support.

With this setting, running `cargo build` or `cargo run` automatically
compiles for the specified target, making cross-compilation seamless.

:::info
The target triple for the Raspberry Pi Pico 1 is `thumbv6m-none-eabi`.
:::

## Binary format

To be able ro properly run the code, the Raspberry Pi Pico (1 and 2) expects a certain binary format.
The compiler and the linker, both provided by Rust, have to make sure that the generated
binary code meets the requirements, otherwise the Raspberry Pi Pico will not start.

### Sections

The binary file is generated as a collection of sections. Each section has:
- size (in bytes)
- the address of the section in RAM when the firmware runs (`VMA`, *Virtual Memory Address*) 
- the address of the section when it is stored into flash (`LMA`, *Load Memory Address*)
- the type

#### Section types
| Type | Description |
|-|-|
| *TEXT* | Contains the binary code the the processor executes |
| *DATA* | Contains data used by the firmware, usually variables |
| *BSS* | Contains uninitialized or initialized with `0` data, usually uninitialized global variables and variables initialized to 0 |
| *DEBUG* | Contains debug information used by the debugger software. |

:::info
DEBUG type sections have no addresses (`0x00000000`), as it they are never loaded to the device. These sections
are used by the debugging software to display meaningful information to developers. Among the information
store here we can find:
- source code to binary code mappings
- variable name mappings
- function name mappings
:::

The binary file for the Raspberry Pi Pico 2 is organized to ensure proper 
execution and booting, with specific sections for the developer's code and 
variables. The first section that holds the developer’s code is the *`.text`* 
section. This section contains all the executable instructions that make up 
the application’s logic. It is located after the *`.start_block`* and 
*`.vector_table`* sections, and it is placed into flash memory, ready to 
be loaded and executed when the system starts. This is where the developer's 
main program logic resides.

Following the *`.text`* section, the *`.data`* section contains 
initialized global and static variables. These variables are stored in flash 
memory and are copied into RAM at startup. The developer’s predefined values 
for global variables are stored here, so they can be used during runtime. 
In contrast, the *`.bss`* section holds uninitialized variables. These 
variables are zeroed out during the boot process and are stored in RAM to 
ensure that the program can access them during execution.

The *`.rodata`* section follows, storing read-only data like string literals 
and constant values. These values are also stored in flash memory and are used 
throughout the application without modification. The *`.rodata`* section 
helps to conserve RAM by storing constant data in the flash memory instead.

Once the developer’s code and variables are in place, the firmware image ends 
with the *`.end_block`* section. This section marks the end of the firmware 
and ensures that no additional data is written past this point. It is important 
for memory management, preventing the accidental overwrite of critical memory 
regions during updates or execution.

### Inspect binaries

When working in Rust for the Raspberry Pi Pico 2, `rust-objdump` can be used to 
inspect the compiled binary and examine its memory layout. The output includes 
various sections that are crucial for embedded development.  

| Section         | Fixed Offset  | Description |
|----------------|--------------|-------------|
| *`.vector_table`* | `0x10000000` | Contains the initial stack pointer value and interrupt vector table. Essential for system startup and exception handling, allowing the processor to correctly respond to interrupts. |
| *`.start_block`* | `0x10000114` | Holds boot metadata, including information needed by the bootloader to validate and execute the firmware correctly. Ensures that the correct application runs after a reset. |
| *`.text`* | N/A | Stores executable code, typically placed in flash memory. Optimizing this section can reduce flash usage and improve execution efficiency. |
| *`.rodata`* | N/A | Contains read-only data, such as string literals and constants, stored in flash memory. Helps minimize RAM usage. |
| *`.data`* | N/A | Includes initialized variables that are stored in flash and copied to RAM during startup. Used for global and static variables requiring predefined values. |
| *`.bss`* | N/A | Represents uninitialized variables that are zeroed out in RAM before execution. Large `.bss` sections can impact RAM availability. |
| *`.bi_entries`* | N/A | Contains boot information entries used by the RP2350 ROM bootloader and firmware updater to manage and validate firmware images. |
| *`.end_block`* | N/A | Marks the end of the firmware image. This section helps bootloaders determine the total size of the firmware and ensures that no unexpected data is included beyond this point. It is used for integrity checks and defining boundaries for updates or memory protection. |


#### Pico 1 vs Pico 2
The primary difference between the Raspberry Pi Pico 1 and Pico 2 in terms of 
firmware layout is the presence of the *`.boot_loader`* section in the Pico 1, 
which is not present in the Pico 2. The *`.boot_loader`* section in the Pico 1 
is located at a fixed offset of `0x10000000` and contains the bootloader code 
along with necessary metadata for bootstrapping the device. 

The *`.vector_table`*  section in the Pico 1 is placed immediately 
after the *`.boot_loader`* section, 
unlike the Pico 2 where it is located at the beginning of the flash memory at 
`0x00000000`. 

The Pico 2 uses the *`.start_block`* and *`.end_block`* sections 
to handle boot metadata and firmware boundaries, while the Pico 1 relies on the 
bootloader for these tasks. Furthermore, the Pico 1 does not have a fixed 
*`.end_block`* section, which is used in the Pico 2 to mark the end of the 
firmware image. 

Despite these differences, both devices share a similar overall 
firmware structure, with the *`.text`*, *`.rodata`*, *`.data`*, and *`.bss`* 
sections serving similar purposes in both devices.


### Install cargo binutils
Before you can use `rust-objdump` with Rust projects, you'll need to install `cargo-binutils`.


```bash
cargo install cargo-binutils
rustup component add llvm-tools
```

### Check section headers

<Tabs>
  <TabItem value="rp2350" label="Raspberry Pi Pico 2" default>

```shell
rust-objdump --section-headers target/thumbv8m.main-none-eabihf/debug/<executable_name>
```

```shell
Sections:
Idx Name            Size     VMA      LMA      Type
  0                 00000000 00000000 00000000 
  1 .vector_table   00000114 10000000 10000000 DATA
  2 .start_block    00000028 10000114 10000114 DATA
  3 .text           0000b190 1000013c 1000013c TEXT
  4 .bi_entries     00000010 1000b2cc 1000b2cc DATA
  5 .rodata         000030e4 1000b2e0 1000b2e0 DATA
  6 .data           00000488 20000000 1000e3c4 TEXT
  7 .gnu.sgstubs    00000000 1000e860 1000e860 DATA
  8 .bss            000181bc 20000488 20000488 BSS
  9 .uninit         00000400 20018644 20018644 BSS
 10 .end_block      00000000 1000e860 1000e860 DATA
 11 .defmt          00000023 00000000 00000000 
 12 .debug_abbrev   0000b8bb 00000000 00000000 DEBUG
 13 .debug_info     000ea40f 00000000 00000000 DEBUG
 14 .debug_aranges  00009a70 00000000 00000000 DEBUG
 15 .debug_ranges   00032380 00000000 00000000 DEBUG
 16 .debug_str      000eff8d 00000000 00000000 DEBUG
 17 .comment        00000099 00000000 00000000 
 18 .ARM.attributes 0000003a 00000000 00000000 
 19 .debug_frame    0001b444 00000000 00000000 DEBUG
 20 .debug_line     0006ed68 00000000 00000000 DEBUG
 21 .debug_loc      00001e3a 00000000 00000000 DEBUG
 22 .symtab         00007530 00000000 00000000 
 23 .shstrtab       00000101 00000000 00000000 
 24 .strtab         0000f6ca 00000000 00000000 
```

  </TabItem>
  <TabItem value="rp2040" label="Raspberry Pi Pico">

```shell
rust-objdump --section-headers target/thumbv6m-none-eabi/debug/<executable_name>
```

```shell
Sections:
Idx Name            Size     VMA      Type
  0                 00000000 00000000 
  1 .vector_table   000000c0 10000100 DATA
  2 .boot_loader    00000100 10000000 DATA
  3 .text           00000b10 100001c0 TEXT
  4 .rodata         000001a4 10000cd0 DATA
  5 .data           00000000 20000000 DATA
  6 .gnu.sgstubs    00000000 10000e80 TEXT
  7 .bss            00000000 20000000 BSS
  8 .uninit         00000000 20000000 BSS
  9 .debug_abbrev   00001bce 00000000 DEBUG
 10 .debug_info     00025316 00000000 DEBUG
 11 .debug_aranges  000014b8 00000000 DEBUG
 12 .debug_str      0003c860 00000000 DEBUG
 13 .debug_pubnames 000175c6 00000000 DEBUG
 14 .debug_pubtypes 00000ee6 00000000 DEBUG
 15 .comment        00000073 00000000 
 16 .ARM.attributes 00000032 00000000 
 17 .debug_frame    00004444 00000000 DEBUG
 18 .debug_line     00023790 00000000 DEBUG
 19 .debug_ranges   00016df8 00000000 DEBUG
 20 .debug_loc      00000074 00000000 DEBUG
 21 .symtab         00000970 00000000 
 22 .shstrtab       00000103 00000000 
 23 .strtab         00000fe4 00000000 
```
  
  </TabItem>
</Tabs>





### Disassemble a specific section

```bash
rust-objdump --disassemble -j .section_name target/thumbv6m-none-eabi/debug/<executable_name>
```

:::info

`cargo objdumb` and `rust-objdump` tools use llvm's `objdump` tool.
Some terminals do not parse parameters proxied to `llvm-objdump` command.
If this happens please use `llvm-objdump` script directly like so

```shell
llvm-objdump <path_to_binary> --section.headers
```

:::

[^firmware]: Software that is running on microcontrollers is usually called *firmware*. The words is a combination of the words *firm* and *software* and means the software that the vendor firm of the device has uploaded.

## Empty firmware

An *empty firmware* is a piece of software running on a device that boots and does puts 
the device in an endless loop. To boot, the firmware has to perform the following:
- do not depend on the standard library (`#![no_std]`)
- do not provide the standard `main` function called by the operating system (`#![no_main]`)
- provide the `.start_block` and `.end_block` sections (or `.bootloader` for the Pico 1);
- provide the `.interrupt_vector` section with pointers to interrupts;
- copy the DATA sections from Flash to the correct address in RAM;
- initialize the BSS section in RAM with 0 values
- jump to the `main` function and never return.

### The `.interrupt_vector` section

The `.interrupt_section` is provided by `rp235x_hal` crate (or `rp2040_hal` for the Pico 1).
Importing this crate is enough to provide a valid interrupt vector.


```rust
#![no_std]
#![no_main]

// we use as _ to avoid a compiler warning
// saying that the crate is not used
use rp235x_hal as _;
```

### The `.start_block` and `.end_blocks`

The `rp235x_hal` crate provides the valid `.start_block` and `.end_block`.

```rust
use rp235x_hal::block::ImageDef;

#[link_section = ".start_block"]
#[used]
pub static IMAGE_DEF: mageDef = ImageDef::secure_exe();
```

This code creates a static variable `IMAGE_DEF` of type `ImageDef` and places it 
in the `.start_block` section, a dedicated section for bootloader 
or secure boot metadata. The `#[used]` attribute ensures the variable is 
included in the binary, even if it isn't directly referenced, 
which is crucial for secure boot functionality or other boot-related processes.

The `secure_exe` function creates a `.start_block` that instructs the `BOOTROM` of the 
Raspberry Pi Pico 2 to start the firmware in secure execution mode. The processor
always starts in secure execution mode and has to be switched to unsecure mode
by the firmware.

:::warning
The `#[used]` attribute is important as linkers will discard code that is
not used to lower the size of the binary. The `IMAGE_DEF` variable is not 
directly used by anything in the firmware and might be discarded.
:::

The `.end_block` is automatically inserted by the linker using the `memory.x` file.

### The `main` function

When writing software that runs on top of an operating system, the operating system
is responsible for initializing the memory of the software and the calling 
of the `main` function. 

Embedded firmware that does not run on top of an operating system has to perform the
memory initialization tasks and calling the `main` function itself.

The Rust Embedded Working Group provides a crate called `cortex_m_rt` (*Cortex-M Runtime*) that
exposes the macro `entry!` to perform these tasks. The macro is placed on top of a function
that takes no parameters and does no return (`!`).

```rust
use cortex_m_rt::entry;

#[entry]
fn main() -> ! {
  loop {}
}
```

:::info
The important aspect is the usage of the `#[entry]` macro, 
while the name of the function does not need to be `main`.
:::

The `entry!` macro will rewrite the `main` function and add all the initialization code.

:::note
Different frameworks like `embassy-rs` will use different entry macros.
:::

## Flashing firmware

To run firmware on the Raspberry Pi Pico 2, the 
compiled program must be transferred to the device's flash (non-volatile) memory. This 
process is called *flashing*, and it ensures that the firmware remains on the 
device even after a power reset. 

A flashing tool is software that communicates 
with the device through a debug probe or other interfaces, such as USB or 
*UART*, to write the firmware to the correct memory location. Many flashing tools 
also verify the uploaded firmware to ensure data integrity and provide 
additional features like chip erasing or memory protection configuration.

When developing Rust firmware for the Raspberry Pi Pico 2, `probe-rs` is the 
preferred flashing tool to upload and debug code. 

After building the firmware using `cargo build`, an ELF file will be generated in
`target/thumbv8m.main-none-eabihf/debug/$app_name`. This file can be flashed to the
board using:

```sh
probe-rs flash --chip RP235x target/thumbv8m.main-none-eabihf/debug/$app_name
```

:::info
Replace $app_name with the name of the firmware's crate, usually the name of the folder
where the firmware source resides.
:::


### Using `cargo run`

On a computer, running a Rust program with `cargo run` compiles the source 
code into an executable and immediately starts it. This command streamlines 
development by combining compilation and execution into a single step.

A similar process applies when using `cargo run` to develop firmware for the Raspberry 
Pi Pico 2. Instead of just compiling and running a program on the host computer, 
`cargo run` cross compiles the firmware and flashes it onto the target device in one 
step. Under the hood, it uses `probe-rs` to detect the connected debug probe 
and handle the flashing process automatically. This eliminates the need for 
separate flashing tools, making firmware development as seamless as running a 
Rust program on a computer.

To be able to use `cargo run` for flashing firmware, a runner has to be specified in the
`.cargo/config.toml` file. The following lines have to be added.

```toml
[target.'cfg(all(target_arch = "arm", target_os = "none"))']
runner = "probe-rs run --chip RP235x"
```

:::warning
Make sure the correct `[target]` is specified in the `.cargo/config.toml` configuration file. See the
[cross-compiling](#using-a-configuration-file) section.
:::

This setup makes flashing firmware to the Raspberry Pi Pico 2 as simple
as running a Rust program on a computer.

## Printing messages

When developing embedded applications, debugging can be challenging due to 
the lack of standard output (such as `println!`). Printed messages need to be generated 
on the target device and sent to the host computer
where they are displayed to a console. 

Two common techniques to 
retrieve debug information from an embedded system are *semihosting* and  
*`defmt`*. Both methods provide insight into program execution but work  
differently and are suited for different use cases.

### Semihosting
Semihosting is a debugging mechanism that allows an embedded system to 
communicate with a host computer via a debugger. It enables operations like:  
- printing debug messages (`println!`)  
- reading input from the host

:::info
Semihosting requires a hardware debugger.
:::

This works in there steps:
1. The embedded firmware executes a special *semihosting instruction*.  
2. The debugger software (e.g., `gdb` with `probe-rs`) intercepts the request.  
3. The debugger software processes the request and returns the result to the firmware.

Semihosting is very simple to implement, but has a big drawback, it is slow 
and cannot be used in production. 

:::note
Printing a panic message takes more than 2 seconds.
:::

#### Printing a message

Semihosting for Cortex-M is implemented by the `cortex_m_semihosting` crate. This
exposes the `hprintln!` is a macro used for printing messages to the host system. 
This macro behaves like `println!`, but instead of 
printing to the terminal, it sends the output to the debugger, which then 
transmits it to the host system.

```rust
#![no_std]
#![no_main]

use cortex_m_rt::entry;
use cortex_m_semihosting::hprintln;

#[entry]
fn main() -> ! {
  hprintln!("Device has started").unwrap();
  // write the rest of the code here
  loop {}
}
```

:::note
The `unwrap` method is called on `hprintln!` to handle the result of the logging operation. 
In real applications, you might want to handle potential 
errors more gracefully. In this case, if `hprintln!` fails, the device just stop working.
:::

:::tip
The main advantage of semihosting is that it works with all the embedded frameworks.
:::

#### Printing the panic

The Rust language provides a special function called the *panic handler* that gets 
called in case things go wrong. For instance attempting to divide to 0 will call the
panic handler.

In embedded systems, the *panic handler* is used to handle unexpected runtime errors.  
Using `hprintln!` in the panic handler allows developers to print helpful debug  
messages when the program encounters a panic, making it easier to solve issues. 

When using `#![no_std]`, developers have to define their own panic handler.

```rust
#![no_std]
#![no_main]

use cortex_m_rt::entry;
use cortex_m_semihosting::hprintln;

#[entry]
fn main() -> ! {
    // Trigger a panic by dividing by zero (for demonstration purposes)
    let result = divide_by_zero();
    hprintln!("Result: {}", result).unwrap();

    loop {}
}

// Simulate a division by zero panic
fn divide_by_zero() -> u32 {
    let a = 1;
    let b = 0;
    a / b  // This will trigger a panic
}

// Define the panic handler
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    // Print a panic message
    hprintln!("Panic occurred: {:?}", info).unwrap();

    // Enter an infinite loop to halt the system after a panic
    loop {}
}
```

The `divide_by_zero` function is intentionally written to trigger a panic
(dividing by zero).
- the panic_handler is defined using the `#[panic_handler]` attribute, when a panic occurs, this handler will be called;
- inside the panic_handler, `hprintln!` is used to print the panic message (`Panic occurred: ...`) to the host system via semihosting.
- the program enters an infinite loop (`loop {}`) to halt the system after a panic, preventing the device from continuing to run.

:::info
Panic handlers are usually defined by the frameworks. `embassy-rs` does define its own panic handler.
:::

### Using `defmt`

Another drawback if semihosting is that
all the strings used in the debug messages are stored into the firmware's DATA
sections and are flashed to the device. All the formating of these strings
is done by the device.

The [`defmt`](https://github.com/knurling-rs/defmt) crate is a compact logging framework 
designed for Rust-based embedded systems. Its name comes from *Deferred Formatting*. Instead of sending full log messages, 
it transmits compressed binary data, which is later decoded on the host.  

This works in two steps:
1. the firmware sends compressed log data via a debug probe (e.g., using `probe-rs`) or another transport like UART (serial port);
2. the host tool (`defmt-print`) decodes the data and prints human-readable logs.  

Using `defmt` implies working with its own printing macros: 
- `error!` used for logging errors, that mean that the firmware cannot conitnue to correctly run;
- `warn!` used for logging warning messages, that are usually recoverable errors, and the framework can conitnue to run correctly;
- `info!` use for logging information messages
- `debug!` used for logging debug messages that should not be displayed under normal functioning;
- `trace!` used for logging almost all the actions of the firmware, messages that should be enable only when the firmware does not work correctly and needs detailed debugging. 

#### Transports

One of the key features of `defmt` is its flexible transport system, allowing developers 
to choose how the log data is transmitted.  
Here, we'll highlight *RTT* (*Real-Time Transfer*) and *UART*.

*RTT* is one of the most powerful transport solutions for embedded debugging. 
It is a high-speed communication protocol that allows log data to be sent from 
the embedded system to the host system in real time. RTT works through the 
debugger's *SWD* (*Serial Wire Debug*) interface, which allows communication 
between the device and the host without requiring an additional *UART* or *USB* 
connection. 

:::info
Using *RTT* requires a debugger.

*RTT* has several key advantages over traditional *UART*. It offers much higher 
data transfer speeds, making it ideal for applications that need frequent 
log output or high-throughput debugging. Moreover, *RTT* doesn't require a 
separate serial interface or special drivers on the host system, as the 
debugger itself handles the communication. The real-time nature of *RTT* is 
perfect for debugging critical, time-sensitive systems.
:::

*UART* is one of the oldest and most commonly used serial communication protocols 
in embedded systems. It’s well-supported by almost every microcontroller and 
platform, and it provides a straightforward way to send log data to a host system. 
In the context of `defmt`, *UART* can be used to transmit log data as ASCII or 
binary over a serial connection, where it is then decoded by a terminal or 
host application.

:::info
While *UART* is slower than RTT, it remains a popular solution due to its simplicity 
and widespread availability. It can be easily set up on most microcontrollers and 
is supported by many *USB-to-serial* adapters, making it accessible for both 
beginners and experienced developers. However, it has limitations in terms of 
speed and real-time debugging capabilities, especially in cases with large log 
outputs or higher data transfer requirements.
:::

#### Example

This example demonstrates how to use `defmt` for logging in an embedded system, 
handle panics, and send log messages over *RTT*. 

```rust
#![no_std]
#![no_main]

use cortex_m_rt::entry;
use defmt::{error, info};
// use RTT for defmt transport
use defmt_rtt as _;

#[entry]
fn main() -> ! {
  info!("Device has started");
  panic!("panic here");
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("{:?}", info);
    loop {}
}
```

The `defmt` crate is used for logging, and two macros are employed in this example: `info!` and `error!`. The `info!` macro is used to log informational messages, such as when the device starts up. The `error!` macro is used in the panic handler to log error messages if the system encounters a panic. 
The logging data is transmitted via *RTT* using the `defmt_rtt` crate, which is imported but not explicitly called. 
The use of RTT enables real-time, high-speed communication between the embedded system and the host, 
making it suitable for debugging in time-sensitive applications.

In the `main` function, the program begins by logging the message `"Device has started"` with the `info!` macro. 
Following this, the `panic!` macro is called, simulating a panic condition. This could be triggered for various 
reasons, such as an unexpected error or failed condition in the embedded system.

The *panic handler* logs the panic information using the `error!` macro. The `info` parameter passed to the panic handler contains details about the panic, which are logged for debugging purposes. 
After logging the error, the program enters an infinite loop (`loop {}`) to prevent further execution, 
effectively halting the system in a controlled manner. This is a common pattern in embedded systems when 
handling critical errors or panics.

### Semihosting and `defmt`

This table show the advantgaes and disadvantages of both methods.

| Feature       | Semihosting                        | `defmt`                         |
|--------------|----------------------------------|--------------------------------|
| **Performance** | Slow (halts CPU)                | Fast (minimal overhead)        |
| **Output Format** | Plain text (`hprintln!`)        | Compressed binary logs        |
| **Debugger Required?** | Yes                              | No (can use other transports) |
| **Memory Usage** | High (standard Rust formatting) | Low (compact binary format)   |
| **Use Case** | Debugging with full text output  | Real-time logging on embedded devices |
